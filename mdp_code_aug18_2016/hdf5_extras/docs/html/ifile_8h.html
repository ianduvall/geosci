<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>HDF5 Extras: src/ifile.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HDF5 Extras
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Convenience Functions for using HDF5 Better</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ifile.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;hdf5.h&gt;</code><br />
<code>#include &lt;sqlite3.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="globals_8h_source.html">globals.h</a>&quot;</code><br />
</div>
<p><a href="ifile_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIFILE.html">IFILE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4c87f2422d07b33f43a7563a96292870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c87f2422d07b33f43a7563a96292870"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_CLOSED</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a4c87f2422d07b33f43a7563a96292870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec8299bd57bfaba837e7899337b8611"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ec8299bd57bfaba837e7899337b8611"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_R</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a5ec8299bd57bfaba837e7899337b8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f83ada72414797b0b6cb4362a43e91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67f83ada72414797b0b6cb4362a43e91"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_W</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a67f83ada72414797b0b6cb4362a43e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d8d227f8792fa45ebaa6af8c31679"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a325d8d227f8792fa45ebaa6af8c31679"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_A</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a325d8d227f8792fa45ebaa6af8c31679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad598a331780469064885cefe0c2f0252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad598a331780469064885cefe0c2f0252"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_RP</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ad598a331780469064885cefe0c2f0252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7bf710c4fd9b9580db050bab420eba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf7bf710c4fd9b9580db050bab420eba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_WP</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:adf7bf710c4fd9b9580db050bab420eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f8bdaeab33c39ad16d2993fd0f3fb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6f8bdaeab33c39ad16d2993fd0f3fb2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_AP</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ac6f8bdaeab33c39ad16d2993fd0f3fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f116afdad5d032235ff5fb96cddc6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06f116afdad5d032235ff5fb96cddc6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_WX</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a06f116afdad5d032235ff5fb96cddc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd8ee5e1f2c87bbcca41e578468c6a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fd8ee5e1f2c87bbcca41e578468c6a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_WXP</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a3fd8ee5e1f2c87bbcca41e578468c6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423bfd0d629d4e9dca21701289b4e0fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a423bfd0d629d4e9dca21701289b4e0fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_SUCCESS</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a423bfd0d629d4e9dca21701289b4e0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194b76ce6b8488bacce30f9db4cee85a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194b76ce6b8488bacce30f9db4cee85a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFILE_FAILURE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a194b76ce6b8488bacce30f9db4cee85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a659760c048381d534347487e14cd5e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25">IFileOpen</a> (hid_t file_id, const char *ifilename, const char *access)</td></tr>
<tr class="memdesc:a659760c048381d534347487e14cd5e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileOpen is used to open an internal file in a GeoSci File.  <a href="#a659760c048381d534347487e14cd5e25">More...</a><br /></td></tr>
<tr class="separator:a659760c048381d534347487e14cd5e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ac8967cccb663f226269e3e56c2332"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#ac4ac8967cccb663f226269e3e56c2332">IFileClearError</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:ac4ac8967cccb663f226269e3e56c2332"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileClearError clears the error condition on an internal file.  <a href="#ac4ac8967cccb663f226269e3e56c2332">More...</a><br /></td></tr>
<tr class="separator:ac4ac8967cccb663f226269e3e56c2332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8f114749f9cc332e2cf013098671a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5">IFileClose</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:a6c8f114749f9cc332e2cf013098671a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileClose closes an internal file in a GeoSci File.  <a href="#a6c8f114749f9cc332e2cf013098671a5">More...</a><br /></td></tr>
<tr class="separator:a6c8f114749f9cc332e2cf013098671a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf332e19de762dcb8236862d6b5a937"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#aaaf332e19de762dcb8236862d6b5a937">IFileEOF</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:aaaf332e19de762dcb8236862d6b5a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileEOF returns the End-Of-File condition of the previous internal read.  <a href="#aaaf332e19de762dcb8236862d6b5a937">More...</a><br /></td></tr>
<tr class="separator:aaaf332e19de762dcb8236862d6b5a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c803c53f6270b21c375b7e07b05f1c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a6c803c53f6270b21c375b7e07b05f1c8">IFileError</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:a6c803c53f6270b21c375b7e07b05f1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileError returns error condition on an internal file.  <a href="#a6c803c53f6270b21c375b7e07b05f1c8">More...</a><br /></td></tr>
<tr class="separator:a6c803c53f6270b21c375b7e07b05f1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc8db0aa84870da8326e8b330d9849a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#acdc8db0aa84870da8326e8b330d9849a">IFileFlush</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:acdc8db0aa84870da8326e8b330d9849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileFlush flushes unwritten buffers to an internal file in a GeoSci File.  <a href="#acdc8db0aa84870da8326e8b330d9849a">More...</a><br /></td></tr>
<tr class="separator:acdc8db0aa84870da8326e8b330d9849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825ee82a052e84aa6a0601f6ba11e77a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a825ee82a052e84aa6a0601f6ba11e77a">IFileGetc</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:a825ee82a052e84aa6a0601f6ba11e77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileGetc reads a character from an internal file.  <a href="#a825ee82a052e84aa6a0601f6ba11e77a">More...</a><br /></td></tr>
<tr class="separator:a825ee82a052e84aa6a0601f6ba11e77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afc35a680bf7e55be809265a899aef8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a3afc35a680bf7e55be809265a899aef8">IFileGets</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, char *str, int num)</td></tr>
<tr class="memdesc:a3afc35a680bf7e55be809265a899aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileGets reads characters from an internal file in a geosci file, and stores them as a string until the maximum number of characters have been read or either a newline or the end-of-file is reached, whichever happens first.  <a href="#a3afc35a680bf7e55be809265a899aef8">More...</a><br /></td></tr>
<tr class="separator:a3afc35a680bf7e55be809265a899aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40774bec8a23ec055276666af845a64b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a40774bec8a23ec055276666af845a64b">IFileSeek</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, long int offset, int origin)</td></tr>
<tr class="memdesc:a40774bec8a23ec055276666af845a64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileSeek moves to a position in an internal file.  <a href="#a40774bec8a23ec055276666af845a64b">More...</a><br /></td></tr>
<tr class="separator:a40774bec8a23ec055276666af845a64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba9b29cbd1df9a22516366c96c528fa"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#abba9b29cbd1df9a22516366c96c528fa">IFileTell</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:abba9b29cbd1df9a22516366c96c528fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileTell retrieves the current read/write position in an internal file.  <a href="#abba9b29cbd1df9a22516366c96c528fa">More...</a><br /></td></tr>
<tr class="separator:abba9b29cbd1df9a22516366c96c528fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a163f17d23c422baeebd61229f70c40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a7a163f17d23c422baeebd61229f70c40">IFileRewind</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:a7a163f17d23c422baeebd61229f70c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileRewind moves to the start of an internal file.  <a href="#a7a163f17d23c422baeebd61229f70c40">More...</a><br /></td></tr>
<tr class="separator:a7a163f17d23c422baeebd61229f70c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361dcf308fbd5daa498812775caef88c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a361dcf308fbd5daa498812775caef88c">IFilePerror</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, const char *str)</td></tr>
<tr class="memdesc:a361dcf308fbd5daa498812775caef88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFilePerror prints latest error for an internal file.  <a href="#a361dcf308fbd5daa498812775caef88c">More...</a><br /></td></tr>
<tr class="separator:a361dcf308fbd5daa498812775caef88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade52718b208c03db3694dbbdcf30a205"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#ade52718b208c03db3694dbbdcf30a205">IFileReadAccess</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:ade52718b208c03db3694dbbdcf30a205"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileReadAccess reads access code of an internal file.  <a href="#ade52718b208c03db3694dbbdcf30a205">More...</a><br /></td></tr>
<tr class="separator:ade52718b208c03db3694dbbdcf30a205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169de07d52b678ebcd4cafa3d7852b79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a169de07d52b678ebcd4cafa3d7852b79">IFileReadAccessHDF</a> (hid_t dataset_id)</td></tr>
<tr class="memdesc:a169de07d52b678ebcd4cafa3d7852b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileReadAccessHDF reads access code of an internal file.  <a href="#a169de07d52b678ebcd4cafa3d7852b79">More...</a><br /></td></tr>
<tr class="separator:a169de07d52b678ebcd4cafa3d7852b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9797ae1226f5e7dc952e6686adfd8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a1b9797ae1226f5e7dc952e6686adfd8c">IFileWriteAccess</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, int code)</td></tr>
<tr class="memdesc:a1b9797ae1226f5e7dc952e6686adfd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileWriteAccess writes a new access code for an internal file.  <a href="#a1b9797ae1226f5e7dc952e6686adfd8c">More...</a><br /></td></tr>
<tr class="separator:a1b9797ae1226f5e7dc952e6686adfd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb191751816b8560f059ca213c725a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a5bb191751816b8560f059ca213c725a5">IFileAllocate</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, long int offset, long int length)</td></tr>
<tr class="memdesc:a5bb191751816b8560f059ca213c725a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileAllocate is used to allocate more space to an internal file.  <a href="#a5bb191751816b8560f059ca213c725a5">More...</a><br /></td></tr>
<tr class="separator:a5bb191751816b8560f059ca213c725a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36409944c39397b10b715e02478d560"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#af36409944c39397b10b715e02478d560">IFilePrintf</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, const char *format,...)</td></tr>
<tr class="memdesc:af36409944c39397b10b715e02478d560"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFilePrintf writes formatted data to an internal file.  <a href="#af36409944c39397b10b715e02478d560">More...</a><br /></td></tr>
<tr class="separator:af36409944c39397b10b715e02478d560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7e66cd5decd8a753cc05d87e796399"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a8a7e66cd5decd8a753cc05d87e796399">IFilePutc</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, char character)</td></tr>
<tr class="memdesc:a8a7e66cd5decd8a753cc05d87e796399"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFilePutc writes a single character to an internal file.  <a href="#a8a7e66cd5decd8a753cc05d87e796399">More...</a><br /></td></tr>
<tr class="separator:a8a7e66cd5decd8a753cc05d87e796399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2e70727c241df05141bfebccbea299"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a5a2e70727c241df05141bfebccbea299">IFilePuts</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, const char *string)</td></tr>
<tr class="memdesc:a5a2e70727c241df05141bfebccbea299"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFilePuts writes a string to an internal file.  <a href="#a5a2e70727c241df05141bfebccbea299">More...</a><br /></td></tr>
<tr class="separator:a5a2e70727c241df05141bfebccbea299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ec9c17d545304d3a89fa6bc6145317"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a72ec9c17d545304d3a89fa6bc6145317">IFileRead</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, void *buf, int size, int count)</td></tr>
<tr class="memdesc:a72ec9c17d545304d3a89fa6bc6145317"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileRead reads the requested number of bytes from an internal file in a geosci file.  <a href="#a72ec9c17d545304d3a89fa6bc6145317">More...</a><br /></td></tr>
<tr class="separator:a72ec9c17d545304d3a89fa6bc6145317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45d5e4d60551a22f2733addc723cc36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#ad45d5e4d60551a22f2733addc723cc36">IFileReadStatus</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, char **message)</td></tr>
<tr class="memdesc:ad45d5e4d60551a22f2733addc723cc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileReadStatus reads the status properties of an internal file.  <a href="#ad45d5e4d60551a22f2733addc723cc36">More...</a><br /></td></tr>
<tr class="separator:ad45d5e4d60551a22f2733addc723cc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c255b65dccaf71c2e826a3ecfbd3ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a04c255b65dccaf71c2e826a3ecfbd3ee">IFileWriteStatus</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, int status, const char *message)</td></tr>
<tr class="memdesc:a04c255b65dccaf71c2e826a3ecfbd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileWriteStatus writes the status properties of an internal file.  <a href="#a04c255b65dccaf71c2e826a3ecfbd3ee">More...</a><br /></td></tr>
<tr class="separator:a04c255b65dccaf71c2e826a3ecfbd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d81157c93e90f61645886bc82f4c8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#ae2d81157c93e90f61645886bc82f4c8f">IFileWriteStatusMessage</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, const char *message)</td></tr>
<tr class="memdesc:ae2d81157c93e90f61645886bc82f4c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileWriteStatusMessage writes the status message of an internal file.  <a href="#ae2d81157c93e90f61645886bc82f4c8f">More...</a><br /></td></tr>
<tr class="separator:ae2d81157c93e90f61645886bc82f4c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfedf1cfc33e7e1006f6eeddc98530b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#adfedf1cfc33e7e1006f6eeddc98530b1">IFileScanf</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, const char *format,...)</td></tr>
<tr class="memdesc:adfedf1cfc33e7e1006f6eeddc98530b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileScanf reads formatted data from an internal file.  <a href="#adfedf1cfc33e7e1006f6eeddc98530b1">More...</a><br /></td></tr>
<tr class="separator:adfedf1cfc33e7e1006f6eeddc98530b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b582df33eb77703df1219114a64368"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a52b582df33eb77703df1219114a64368">IFileSetEOF</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, int value)</td></tr>
<tr class="memdesc:a52b582df33eb77703df1219114a64368"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileSetEOF sets End-Of-File condition on an internal file.  <a href="#a52b582df33eb77703df1219114a64368">More...</a><br /></td></tr>
<tr class="separator:a52b582df33eb77703df1219114a64368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcce5509a2d88c4c8d6f9c7cd9c9ccd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#aefcce5509a2d88c4c8d6f9c7cd9c9ccd">IFileSetWriteability</a> (hid_t file_id, const char *name, int property)</td></tr>
<tr class="memdesc:aefcce5509a2d88c4c8d6f9c7cd9c9ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileSetWriteability sets the read/write property of an internal file.  <a href="#aefcce5509a2d88c4c8d6f9c7cd9c9ccd">More...</a><br /></td></tr>
<tr class="separator:aefcce5509a2d88c4c8d6f9c7cd9c9ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c67218594c24854e1bf9eec02519ece"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a8c67218594c24854e1bf9eec02519ece">IFileGetWrite</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:a8c67218594c24854e1bf9eec02519ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileGetWrite gets the read/write property of an internal file.  <a href="#a8c67218594c24854e1bf9eec02519ece">More...</a><br /></td></tr>
<tr class="separator:a8c67218594c24854e1bf9eec02519ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396268f8a6f981e1d514b6a08d545761"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#a396268f8a6f981e1d514b6a08d545761">IFileSetWrite</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, int property)</td></tr>
<tr class="memdesc:a396268f8a6f981e1d514b6a08d545761"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileSetWrite sets the read/write property of an internal file.  <a href="#a396268f8a6f981e1d514b6a08d545761">More...</a><br /></td></tr>
<tr class="separator:a396268f8a6f981e1d514b6a08d545761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada46c060c57740d8109507fd86ab89e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#ada46c060c57740d8109507fd86ab89e7">IFileGetWriteDataset</a> (hid_t dataset_id)</td></tr>
<tr class="memdesc:ada46c060c57740d8109507fd86ab89e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileGetWriteDataset gets the read/write property of an internal file.  <a href="#ada46c060c57740d8109507fd86ab89e7">More...</a><br /></td></tr>
<tr class="separator:ada46c060c57740d8109507fd86ab89e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b0643765d564071f1f55f33ebb6e10"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#ae4b0643765d564071f1f55f33ebb6e10">IFileSize</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:ae4b0643765d564071f1f55f33ebb6e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileSize gets the #bytes in an internal file.  <a href="#ae4b0643765d564071f1f55f33ebb6e10">More...</a><br /></td></tr>
<tr class="separator:ae4b0643765d564071f1f55f33ebb6e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a575404e6e3648952ae70d281b3552"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#af1a575404e6e3648952ae70d281b3552">IFileSizeHDF</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep)</td></tr>
<tr class="memdesc:af1a575404e6e3648952ae70d281b3552"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileSizeHDF gets the #bytes in an internal file.  <a href="#af1a575404e6e3648952ae70d281b3552">More...</a><br /></td></tr>
<tr class="separator:af1a575404e6e3648952ae70d281b3552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18bb2cd94833d1f8f7176d12537695c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#af18bb2cd94833d1f8f7176d12537695c">IFileTruncate</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, long int length)</td></tr>
<tr class="memdesc:af18bb2cd94833d1f8f7176d12537695c"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileTruncate changes the size of an internal file.  <a href="#af18bb2cd94833d1f8f7176d12537695c">More...</a><br /></td></tr>
<tr class="separator:af18bb2cd94833d1f8f7176d12537695c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21affaf53c0b66911c745dd6248ccf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#af21affaf53c0b66911c745dd6248ccf7">IFileWrite</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, const void *buf, int size, int count)</td></tr>
<tr class="memdesc:af21affaf53c0b66911c745dd6248ccf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileWrite writes bytes to an internal file.  <a href="#af21affaf53c0b66911c745dd6248ccf7">More...</a><br /></td></tr>
<tr class="separator:af21affaf53c0b66911c745dd6248ccf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0ba4b82b44ad03f5781d3b5e7021ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ifile_8h.html#aef0ba4b82b44ad03f5781d3b5e7021ac">IFileReadALine</a> (<a class="el" href="structIFILE.html">IFILE</a> *ifilep, char *str, int num)</td></tr>
<tr class="memdesc:aef0ba4b82b44ad03f5781d3b5e7021ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">IFileReadALine reads a string from an internal file.  <a href="#aef0ba4b82b44ad03f5781d3b5e7021ac">More...</a><br /></td></tr>
<tr class="separator:aef0ba4b82b44ad03f5781d3b5e7021ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5bb191751816b8560f059ca213c725a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileAllocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileAllocate is used to allocate more space to an internal file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset, in bytes, from the start of the file where the newly-allocates bytes must start. Should be &gt;= 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length, in bytes, of the region of the newly-allocated bytes. Should be &gt;0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE is returned on success, FALSE otherwise. The error_string variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to add 100 bytes to the end of an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;long int istart, icount;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;istart=IFileSize(ifilep);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;icount = 100L;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;if(!IFileAllocate(ifilep, istart, icount)){</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   printf(&quot;allocate failed\n&quot;);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>If the size of the file is less than offset+len, then the file is increased to this size; otherwise the file size is left unchanged. This function is meant to emulate as close as possible the standard posix_fallocate() function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ac8967cccb663f226269e3e56c2332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileClearError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileClearError clears the error condition on an internal file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE is returned on SUCCESS, FALSE otherwise. The error_string variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to clear any error related to the previous read from an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char c;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;....</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;c = IFileGets(ifilep);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;IFileClearError(ifilep);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C clearerr() function. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c8f114749f9cc332e2cf013098671a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileClose closes an internal file in a GeoSci File. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE is returned on success, FALSE on failure. The error_string variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example 1</dt><dd>Let's assume that one already has an GeoSci file, and one wants to close an internal file name "/somename": <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;if(!IFileClose(ifilep)){</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   printf(&quot;IFileClose failed on /somename\n&quot;);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example 2</dt><dd>Let's assume that one already has an GeoSci file, and one wants to close an internal file that's inside another group: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id, group_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;group_id = GS_GroupCreate(file_id,&quot;/group1&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(group_id &lt; 0) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;GS_GroupCreate failed on /group1\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   exit(-1);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;ifilep = IFileOpen(file_id,&quot;/group1/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   printf(&quot;IFileOpen failed on /group1/somename\n&quot;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   exit(-1);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;if(!IFileClose(ifilep)){</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   printf(&quot;IFileClose failed on /group1/somename\n&quot;);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   exit(-1);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C fclose() function. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaf332e19de762dcb8236862d6b5a937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileEOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileEOF returns the End-Of-File condition of the previous internal read. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE is returned if a previous read tried to read past the end-of-file, FALSE if not. ERROR is returned on any kind of error. The error_string variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to determine if the previous read from an internal file named "/somename" succeeded or not. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;if(!IFileEOF(ifilep)){</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   printf(&quot;previous read DID NOT read past end-of-file\n&quot;);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;} else {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   printf(&quot;previous read DID read past end-of-file\n&quot;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details </dt><dd>This function is meant to emulate as close as possible the standard C feof() function. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c803c53f6270b21c375b7e07b05f1c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileError returns error condition on an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE is returned if "last_operation_status" metadata for the internal file is "SUCCESS", TRUE otherwise. ERROR is returned on any kind of error. The error_string variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to determine if the previous read from an internal file named "/somename" succeeded or not. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(!IFileError(ifilep)){</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   printf(&quot;previous read DID NOT cause an error\n&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;} else {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;previous read DID cause an error\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C ferror() function. </dd></dl>

</div>
</div>
<a class="anchor" id="acdc8db0aa84870da8326e8b330d9849a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileFlush flushes unwritten buffers to an internal file in a GeoSci File. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE is returned on success, FALSE on failure. The error_string variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to flush an internal file named "/somename": <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;if(!IFileFlush(ifilep)){</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   printf(&quot;IFileFlush failed on /somename\n&quot;);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C fflush() function. </dd></dl>

</div>
</div>
<a class="anchor" id="a825ee82a052e84aa6a0601f6ba11e77a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileGetc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileGetc reads a character from an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character read is returned (promoted to an int value). If the file position indicator was at the end-of-file, the function returns ERROR and sets the end-of-file indicator (IFileEOF). If some other reading error happens, the function also returns ERROR, but sets its error indicator (IFileError) instead.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to read the next character from an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int the_int_char;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;char the_char;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;the_int_char = IFileGetc(ifilep);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;if(the_int_char &lt; 0) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   printf(&quot;read failed\n&quot;);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;the_char = (char *)the_int_char;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;...use the_char here....</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C fgetc() function. </dd></dl>

</div>
</div>
<a class="anchor" id="a3afc35a680bf7e55be809265a899aef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* IFileGets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileGets reads characters from an internal file in a geosci file, and stores them as a string until the maximum number of characters have been read or either a newline or the end-of-file is reached, whichever happens first. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, FileClose</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>Pointer to an array of chars where the string read is copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Maximum number of characters to be copied into <code>str</code> (including the terminating null-character).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">On success, the function returns <code>str</code>.</p>
<p>If the end-of-file is encountered while attempting to read a character, the eof indicator is set (IFileEOF). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of <code>str</code> remain unchanged).</p>
<p class="enddd">If a read error occurs, the error indicator (IFileError) is set and a null pointer is also returned (but the contents pointed-to by <code>str</code> may have changed). </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to read the next line of characters (up to the next "\n") from an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char the_string[1000];</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifielp) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;the_string = IFileGets(ifilep, the_string, 1000);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(!the_string) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;read failed\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;...use the_string here....</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C fgets() function. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c67218594c24854e1bf9eec02519ece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileGetWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileGetWrite gets the read/write property of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">TRUE is returned if the internal file is writeable, FALSE if not writeable.</p>
<p class="enddd">ERROR is returned on any kind of error. The error_string variable is also set to a system-specific error code on failure. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to determine if the internal file named "/somename" is writeable. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;status = IFileGetWrite(ifilep);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;if( status ==FALSE){</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   printf(&quot;Cannot write to internal file\n&quot;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;} else if(status == TRUE) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   printf(&quot;Can write to internal file\n&quot;);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;} else {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   printf(&quot;error getting write-status of internal file\n&quot;);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to enable a user to make an internal file have read and write rights like in the standard file system. </dd></dl>

</div>
</div>
<a class="anchor" id="ada46c060c57740d8109507fd86ab89e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileGetWriteDataset </td>
          <td>(</td>
          <td class="paramtype">hid_t&#160;</td>
          <td class="paramname"><em>dataset_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileGetWriteDataset gets the read/write property of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id;</td><td>The handle of the open dataset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"><code>TRUE</code> is returned if the dataset is writeable, <code>FALSE</code> if not writeable.</p>
<p class="enddd">ERROR is returned on any kind of error. The <code>error_string</code> variable is also set to a system-specific error code on failure. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to determine if the internal file named "/somename" is writeable. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;hid_t dataset_id;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;dataset_id = GS_DatasetOpen(file_id,&quot;/somename&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(datset_id &lt; 0) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;GS_DatasetOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;status = IFileGetWriteDataset(ifilep);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;if( status ==FALSE){</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   printf(&quot;Cannot write to internal file\n&quot;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;} else if(status == TRUE) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   printf(&quot;Can write to internal file\n&quot;);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;} else {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   printf(&quot;error getting write-status of internal file\n&quot;);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Detials</dt><dd>This function is meant to enable a user to make an internal file have read and write rights like in the standard file system. </dd></dl>

</div>
</div>
<a class="anchor" id="a659760c048381d534347487e14cd5e25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIFILE.html">IFILE</a>* IFileOpen </td>
          <td>(</td>
          <td class="paramtype">hid_t&#160;</td>
          <td class="paramname"><em>file_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ifilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileOpen is used to open an internal file in a GeoSci File. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_id</td><td>The handle of the open GeoSci file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilename</td><td>The name of the internal file in an existing GeoSci file to be opened. Use Unix filenaming conventions, giving the full pathname, starting with "/". All but the last component of this name must already exist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">access</td><td>Access mode for the IFile, similar to that used for files: <br />
 <ul>
<li>"r" read: Open internal file for input operations. Must already exist.</li>
<li>"w" write: Create an empty file for output operations. If an internal file with the same name already exists, its contents are discarded and the file is treated as a new empty internal file.</li>
<li>"a" append: Open internal file for output at the end of a the file. Output operations always write data at the end of the file, expanding it. Repositioning operations (IFileSeek, IFileSetpos, IFileRewind) are silently ignored. The internal file is created if it does not exist.</li>
<li>"r+" read/update: Open an internal file for update (both for input and output). The file must already exist.</li>
<li>"w+" write/update: Create an empty internal file and open it for update (both for input and output). If an internal file with the same name already exists its contents are discarded and the internal file is treated as a new empty file.</li>
<li>"a+" append/update: Open an internal file for update (both for input and output) with all output operations writing data at the end of the file. Repositioning operations (IFileSeek, IFileSetpos, IFileRewind) affect the next input operations, but output operations move the position back to the end of internal file. The internal file is created if it does not exist.</li>
</ul>
<p class="endtd">The letter "x" can be appended to any "w" specifier (to form "wx" or "w+x"). This subspecifier forces the function to fail if the internal file exists, instead of overwriting it. <br />
 Sometimes a "b" is appended to indicate binary mode for reading and writing, but that is not necessary, so it is ignored. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the internal file is successfully opened, the function returns a pointer to a structure, otherwise a NULL pointer is returned.</dd></dl>
<dl class="section user"><dt>Example 1</dt><dd>Let's assume that one already has an GeoSci file, and one wants to add an internal file, named "somename", off of the root: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example 2</dt><dd>Let's assume that one already has an GeoSci file, and one wants to add an internal file inside another group: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id, group_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;bstring name=bfromcstr(&quot;/group1&quot;);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;group_id = GS_GroupCreate(file_id,name);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;bdestroy(name);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(group_id &lt; 0) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;GroupCreate failed on /group1\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   exit(-1);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;ifilep = IFileOpen(file_id,&quot;/group1/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;IFileOpen failed on /group1/somename\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   exit(-1);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd><p class="startdd">This function is meant to emulate as close as possible the standard C fopen() function.</p>
<p>For internal files open for update (those which include a "+" sign), on which both input and output operations are allowed, the file should be flushed (IFileFlush) or repositioned (IFileSeek, IFileSetpos, IFileRewind) between either a writing operation followed by a reading operation or a reading operation which did not reach the end-of-file followed by a writing operation.</p>
<p>When appropriate, this routine creates a single-dimensional unsigned-8-bit dataset with the given name. The components of the pathname above the filename must already exist, and be HDF5 groups in order for this to work.</p>
<p class="enddd">Note that even if you intend to only read from an IFile, you need to open the GeoSci file for reading AND writing ("r+"). This is because the state of the internal file is written to metadata in the GeoSci file, even if one is only reading from the IFile. </p>
</dd></dl>
<dl class="section user"><dt>Implementation</dt><dd><p class="startdd">For developers, the details of the implementation are presented here.</p>
<p>The complete list of all 34 IFile-related functions is given below:</p>
<ul>
<li>GS_ObjectIsIFile (also contains ObjectIsIFileByID)</li>
<li>GS_ObjectIsMetadataIFile</li>
<li>DatasetGetType</li>
<li>DatasetSetType</li>
<li>IFileAllocate</li>
<li>IFileClearError</li>
<li>IFileClose</li>
<li>IFileEOF</li>
<li>IFileError</li>
<li>IFileFlush</li>
<li>IFileGetc</li>
<li>IFileGets</li>
<li>IFileGetWrite</li>
<li>IFileOpen</li>
<li>IFilePerror</li>
<li>IFilePrintf</li>
<li>IFilePutc</li>
<li>IFilePuts</li>
<li>IFileReadAccess</li>
<li>IFileRead</li>
<li>IFileReadStatus</li>
<li>IFileRewind</li>
<li>IFileScanf</li>
<li>IFileSeek</li>
<li>IFileSetEOF</li>
<li>IFileSetWriteability</li>
<li>IFileSetWrite</li>
<li>IFileSize</li>
<li>IFileTell</li>
<li>IFileTruncate</li>
<li>IFileWriteAccess</li>
<li>IFileWrite</li>
<li>IFileWriteStatus</li>
<li>IFileWriteStatusMessage</li>
</ul>
<p>Some of these are named based on the standard C library functions that they emulate. Others are implementation-specific functions.</p>
<p>The overall idea of a IFile is that of a HDF5 dataset. This dataset is 1-dimensional, with a datatype of unsigned-8-bit. It is infinitely extendable. It has three string attributes:</p>
<ul>
<li>writeable: "TRUE" or "FALSE". The user can set this so that don't accidentally over-write it or delete it. All IFiles are created with writeable="TRUE"</li>
<li>access: an integer betwen 0 and 6, converted to a string. Corresponds to one of the following #define'd parameters: <ul>
<li>IFILE_CLOSED 0 </li>
<li>IFILE_R 1 </li>
<li>IFILE_W 2 </li>
<li>IFILE_A 3 </li>
<li>IFILE_RP 4 </li>
<li>IFILE_WP 5 </li>
<li>IFILE_AP 6</li>
</ul>
These are named based on the access string used during the <a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen()</a> function-call, the "P" meaning "+". This keeps track of how the file was opened so only appropriate operations are allowed. Note that a file that is open cannot be opened by another command: the file must be CLOSED in order to be opened. This implements a very simple locking mechanism</li>
<li>dataset_type: for an IFile this must be "10", which corresponds to the C #define GS_OBJECT_TYPE_IFILE This is needed because image rasters are stored as datasets as well, and we need to distinguish between these.</li>
</ul>
<p>The returned data structure is defined as: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;typedef struct {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  hid_t ifile_id;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  long int file_position;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  int readPastEOF;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  int last_operation_status;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  bstring last_operation_status_message;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  int access;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  long int size;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;} IFILE;</div>
</div><!-- fragment --><p class="enddd"></p>
</dd></dl>
<dl class="section user"><dt></dt><dd>The parameters in this structure are defined as follows:</dd></dl>
<ul>
<li><em>ifile_id</em>: the HDF5 object-id for this dataset.</li>
<li><em>file_position</em>: This is the next byte to read-from or write-to, where file_position=0 means to read/write the first byte in the file.</li>
<li><em>readPastEOF</em>: "TRUE"=1 or "FALSE"=0. Whether the previous operation tried to read past the last byte in the file.</li>
<li><em>last_operation_status</em>: "SUCCESS"=1 or "FAILURE"=0 Each operation on the IFile sets this.</li>
<li><em>last_operation_status_message</em>: a string written by each of the IFile functions, whether they succeed or fail.</li>
<li><em>access</em>: A copy of the dataset-metadata entry.</li>
<li><em>size</em>: The current file size in bytes. This is obtained when opened using HDF5 function calls. Thereafter it is updated by the the functions as needed.</li>
</ul>
<dl class="section user"><dt></dt><dd>Functions that deal with these metadata items are given below. Generally the user should never call any of these, except for:<ul>
<li><a class="el" href="ifile_8h.html#aefcce5509a2d88c4c8d6f9c7cd9c9ccd" title="IFileSetWriteability sets the read/write property of an internal file. ">IFileSetWriteability()</a> for setting the writeability of an IFile when it is closed.</li>
<li><a class="el" href="ifile_8h.html#a6c803c53f6270b21c375b7e07b05f1c8" title="IFileError returns error condition on an internal file. ">IFileError()</a> for determining error status</li>
<li><a class="el" href="ifile_8h.html#a361dcf308fbd5daa498812775caef88c" title="IFilePerror prints latest error for an internal file. ">IFilePerror()</a> for printing the latest error</li>
<li><a class="el" href="ifile_8h.html#aaaf332e19de762dcb8236862d6b5a937" title="IFileEOF returns the End-Of-File condition of the previous internal read. ">IFileEOF()</a> for determining the EOF status of last read</li>
<li><a class="el" href="ifile_8h.html#a40774bec8a23ec055276666af845a64b" title="IFileSeek moves to a position in an internal file. ">IFileSeek()</a> for moving the file position</li>
<li><a class="el" href="ifile_8h.html#abba9b29cbd1df9a22516366c96c528fa" title="IFileTell retrieves the current read/write position in an internal file. ">IFileTell()</a> for determining the file position</li>
<li><a class="el" href="ifile_8h.html#a7a163f17d23c422baeebd61229f70c40" title="IFileRewind moves to the start of an internal file. ">IFileRewind()</a> for setting the file position to 0</li>
</ul>
</dd></dl>
<ul>
<li>GS_ObjectIsIFile &ndash; must be a dataset with dataset_type="1"</li>
<li>GS_DatasetGetType&ndash; returns the dataset_type</li>
<li>GS_DatasetSetType&ndash; sets the dataset_type</li>
<li>IFileClearError &ndash; sets last_operation_status="SUCCESS" and sets last_operation_status_message</li>
<li>IFileError &ndash; returns TRUE if last_operation_status="FAILURE"</li>
<li>IFilePerror &ndash; prints last_operation_status_message</li>
<li>IFileReadStatus &ndash; reads last_operation_status, and last_operation_status_message</li>
<li>IFileWriteStatus &ndash; writes last_operation_status, and last_operation_status_message</li>
<li>IFileWriteStatusMessage &ndash; writes last_operation_status_message</li>
<li>IFileEOF &ndash; returns TRUE if readPastEOF="TRUE"</li>
<li>IFileSetEOF &ndash; writes to readPastEOF</li>
<li>IFileGetWrite &ndash; returns TRUE If writeable="TRUE"</li>
<li>IFileSetWrite &ndash; sets writeability (developer function)</li>
<li>IFileSetWriteability &ndash; sets writeability (user function)</li>
<li>IFileReadAccess &ndash; reads access</li>
<li>IFileWriteAccess &ndash; writes access</li>
<li>IFileSeek &ndash; sets file_position</li>
<li>IFileTell &ndash; reads file_position</li>
<li>IFileRewind &ndash; sets file_position to "0"</li>
</ul>
<dl class="section user"><dt></dt><dd>Functions to deal with the file size directly:</dd></dl>
<ul>
<li>IFileTruncate &ndash; sets size of file (can shrink or grow)</li>
<li>IFileAllocate &ndash; expands file size if needed</li>
<li>IFileSize &ndash; gets the current file size from the struct</li>
<li>IFileSizeHDF &ndash; gets the current file size from HDF</li>
</ul>
<dl class="section user"><dt></dt><dd>Other functions that the user can use include:</dd></dl>
<ul>
<li>IFileOpen &ndash; open an IFile</li>
<li>IFileClose &ndash; close an IFile</li>
<li>IFileFlush &ndash; flush any changes to the IFile to disk</li>
<li>IFileGetc &ndash; read a single character</li>
<li>IFileGets &ndash; read a newline-terminated string</li>
<li>IFileRead &ndash; read a set number of bytes</li>
<li>IFileScanf &ndash; formatted-read from next "line"</li>
<li>IFilePutc &ndash; write a single character</li>
<li>IFilePuts &ndash; write a newline-terminated string</li>
<li>IFileWrite &ndash; write a set number of bytes</li>
<li>IFilePrintf &ndash; write a formatted string</li>
</ul>
<dl class="section user"><dt></dt><dd>Note that there is only ONE COPY of the file state, so there can only be one process that is using it at one time. This is on purpose so that there are no parallel-read-write issues. </dd></dl>

</div>
</div>
<a class="anchor" id="a361dcf308fbd5daa498812775caef88c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFilePerror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFilePerror prints latest error for an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String containing a custom message to be printed before the error message itself. If it is a null pointer, no preceding custom message is printed, but the error message is still printed. By convention, the name of the application itself is generally used as parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">TRUE is returned on success, FALSE otherwise.</p>
<p class="enddd">This function should be called right after the error was produced, otherwise the error of interest can be overwritten by calls to other functions. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to print the latest error related to an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(!IFilePerror(ifilep,NULL)){</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   printf(&quot;perror failed\n&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>Prints the latest error message related to the internal file to <code>stdout</code>, optionally preceded by the custom message provided in str. This function is meant to emulate as close as possible the standard C perror() function. </dd></dl>

</div>
</div>
<a class="anchor" id="af36409944c39397b10b715e02478d560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFilePrintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFilePrintf writes formatted data to an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen()</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>String that contains the text to be written to the internal file. It can optionally contain embedded format specifiers that are replaced by the values specified in subsequent additional arguments and formatted as requested. See docs for <code>fscanf()</code> in any C book for the complete details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>(additional arguments) Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type. There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">On success, the function returns the number of characters successfully written.</p>
<p>If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (<a class="el" href="ifile_8h.html#aaaf332e19de762dcb8236862d6b5a937" title="IFileEOF returns the End-Of-File condition of the previous internal read. ">IFileEOF()</a> or <a class="el" href="ifile_8h.html#a6c803c53f6270b21c375b7e07b05f1c8" title="IFileError returns error condition on an internal file. ">IFileError()</a>). And, if either happens before any data could be successfully written, ERROR is returned.</p>
<p class="enddd">The error_string variable is also set to a system-specific error code on failure. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to write a string to the next line of the internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int an_int;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;int n;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;an_int = 5;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;n =IFilePrintf(ifilep, &quot;The value is: %d&quot;, an_int);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;if(n==1){</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   printf(&quot;successfully wrote the integer: %d\n&quot;,an_int);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;} else {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   printf(&quot;problem writing the integer\n&quot;);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd><p class="startdd">This function is meant to emulate as close as possible the standard C <code>fprintf()</code> function.</p>
<p>Writes the string pointed by format to the internal file. If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.</p>
<p class="enddd">After the format parameter, the function expects at least as many additional arguments as specified by format. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8a7e66cd5decd8a753cc05d87e796399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFilePutc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFilePutc writes a single character to an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">character</td><td>The character to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">On success, TRUE is returned.</p>
<p class="enddd">If some writing error happens, the function returns FALSE, and sets its error indicator (IFileError). </p>
</dd></dl>
<dl class="section user"><dt>Exmaple</dt><dd>Let's assume that one already has an GeoSci file, and one wants to write the character 'a' to an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int the_int_char;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;char the_char;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;the_char = &#39;a&#39;;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;if(!IFilePutc(ifilep, the_char)){</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   printf(&quot;write failed\n&quot;);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C <code>fputc()</code> function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a2e70727c241df05141bfebccbea299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFilePuts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFilePuts writes a string to an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The character string to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE is returned. If some writing error happens, the function returns FALSE, and sets its error indicator (IFileError).</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to write the character string "already" to an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(!IFilePuts(ifilep, &quot;already&quot;)){</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   printf(&quot;write failed\n&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C <code>fputs()</code> function. </dd></dl>

</div>
</div>
<a class="anchor" id="a72ec9c17d545304d3a89fa6bc6145317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t IFileRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileRead reads the requested number of bytes from an internal file in a geosci file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>Pointer to an array where the bytes read are copied to. This must have at least size*count bytes of storage. Using a void pointer here allows the user to pass a buf variable of any type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of each element to be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to read. Each element has a size of "size" bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The total number of elements successfully read is returned.</p>
<p>If this number differs from the count parameter, either a reading error occurred or the end-of-file was reached while reading. In both cases, the proper indicator is set, which can be checked with IFileError and IFileEOF, respectively.</p>
<p class="enddd">If either <code>size</code> or <code>count</code> is less than or equal to zero, the function returns zero and both the internal-file state and the content pointed to by <code>buf</code> remain unchanged. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to read the next 10 characters from an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char *buf;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;buf = (char *)GMalloc(10*sizeof(char));</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!buf){</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;GMalloc error\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   exit(-1);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;if(IFileRead(ifilep, buf, sizeof(char),10) != 10){</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   printf(&quot;read failed\n&quot;);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;...use buf here....</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd><p class="startdd">This function is meant to emulate as close as possible the standard C <code>fread()</code> function.</p>
<p class="enddd">The types of size and count are purposely <code>int</code> and not <code>size_t</code> because if the user accidentally passes a negative value the value becomes a very big number when casted to an unsigned integer, which is what <code>size_t</code> is. In order to detect this error, <code>int</code> is used instead. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ade52718b208c03db3694dbbdcf30a205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileReadAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileReadAccess reads access code of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, one of: <br />
<code>IFILE_CLOSED</code> 0 <br />
<code>IFILE_R</code> 1 <br />
<code>IFILE_W</code> 2 <br />
 <code>IFILE_A</code> 3 <br />
 <code>IFILE_RP</code> 4 <br />
<code>IFILE_WP</code> 5 <br />
<code>IFILE_AP</code> 6 <br />
 On failure, ERROR is returned.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to determine the access code for an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int access_code;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;access_code = IFileReadAccess(ifilep);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(access_code&lt;0){</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;could not obtain access code for internal file\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is used by the IFile* functions to determine how to implement each function for a specific file access code. </dd></dl>

</div>
</div>
<a class="anchor" id="a169de07d52b678ebcd4cafa3d7852b79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileReadAccessHDF </td>
          <td>(</td>
          <td class="paramtype">hid_t&#160;</td>
          <td class="paramname"><em>dataset_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileReadAccessHDF reads access code of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">datset_id</td><td>The hdf-id of the open internal file dataset-object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, one of:<br />
<code>IFILE_CLOSED</code> 0 <br />
<code>IFILE_R</code> 1 <br />
 <code>IFILE_W</code> 2 <br />
<code>IFILE_A</code> 3 <br />
<code>IFILE_RP</code> 4 <br />
<code>IFILE_WP</code> 5 <br />
<code>IFILE_AP</code> 6 <br />
On failure, <code>ERROR</code> is returned.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to determine the access code for an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;his_t dataset_id;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int access_code;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;dataset_id = GS_DatasetOpen(file_id,&quot;/somename&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(dataset_id &lt; 0) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;access_code = IFileReadAccessHDF(dataset_id);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(access_code&lt;0){</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;could not obtain access code for internal file\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is used by the IFile* functions to determine how to implement each function for a specific file access code. </dd></dl>

</div>
</div>
<a class="anchor" id="aef0ba4b82b44ad03f5781d3b5e7021ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileReadALine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileReadALine reads a string from an internal file. </p>
<p><a class="el" href="ifile_8h.html#aef0ba4b82b44ad03f5781d3b5e7021ac" title="IFileReadALine reads a string from an internal file. ">IFileReadALine()</a> reads characters from an internal file in a geosci file, and stores them as a string until the maximum number of characters have been read or either a newline or the end-of-file is reached, whichever happens first.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, FileClose, <a class="el" href="ifile_8h.html#a3afc35a680bf7e55be809265a899aef8" title="IFileGets reads characters from an internal file in a geosci file, and stores them as a string until ...">IFileGets</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>Pointer to an array of chars where the string read is copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Maximum number of characters to be copied into <code>str</code> (including the terminating null-character).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">This function uses <a class="el" href="ifile_8h.html#a3afc35a680bf7e55be809265a899aef8" title="IFileGets reads characters from an internal file in a geosci file, and stores them as a string until ...">IFileGets()</a> to read the data, any errors encountered will cause this routine to return ERROR.</p>
<p>If the read succeeds, but the last character read is NOT a newline, then it returns FALSE.</p>
<p class="enddd">If there are no read errors, and a complete line is read, then TRUE is returned. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to read the next line of characters (up to the next "\n") from an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char the_string[1000];</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifielp) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;status = IFileReadALine(ifilep, the_string, 1000);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(status==ERROR){</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;read failed\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;} else if (status=FALSE){</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   printf(&quot;string is incomplete\n&quot;);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;} else {</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   printf(&#39;complete string read successfully.\n&quot;);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   ...use the_string here....</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>Similar to <a class="el" href="ifile_8h.html#a3afc35a680bf7e55be809265a899aef8" title="IFileGets reads characters from an internal file in a geosci file, and stores them as a string until ...">IFileGets()</a>, but provides clearer return error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad45d5e4d60551a22f2733addc723cc36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileReadStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileReadStatus reads the status properties of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Returned Message associated with the status. No need to GFree it when done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the return value is one of:<br />
 <code>IFILE_SUCCESS</code> &ndash; the last IFile operation succeeded<br />
 <code>IFILE_FAILURE</code> &ndash; the last IFile operation failed<br />
On failure, <code>FALSE</code> is returned. The <code>error_string</code> variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one has created an internal file is named "/somename" and the last write operation may have failed. Let's get the status. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int status;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;char *status_str;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;status = IFileReadStatus(ifilep,&amp;status_str);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;if(!status){</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   printf(&quot;IFileReadStatus failed\n&quot;);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;} else {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   if(status == IFILE_SUCCESS){</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;      printf(&quot;status of last operation is: SUCCESS\n&quot;);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   } else {</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      printf(&quot;status of last operation is: FAILURE\n&quot;);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;   } // endif </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   printf(&quot;status message: %s\n&quot;,status_str);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;} // endif</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function encapsulates reading the IFile status metadata. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a163f17d23c422baeebd61229f70c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileRewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileRewind moves to the start of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> is returned on success, <code>FALSE</code> otherwise. The <code>error_string</code> variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to rewind an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(!IFileRewind(ifilep)){</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   printf(&quot;rewind failed\n&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C <code>rewind()</code> function. </dd></dl>

</div>
</div>
<a class="anchor" id="adfedf1cfc33e7e1006f6eeddc98530b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileScanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileScanf reads formatted data from an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>String that contains a sequence of characters that control how characters extracted from the stream are treated. See docs for <code>fscanf()</code> in any C book for the complete details.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>(additional arguments) Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type. There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function. These arguments are expected to be pointers: to store the result of a IFileScanf operation on a regular variable, its name should be preceded by the reference operator (&amp;) (see example).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reaching of the end-of-file.</p>
<p>If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (<a class="el" href="ifile_8h.html#aaaf332e19de762dcb8236862d6b5a937" title="IFileEOF returns the End-Of-File condition of the previous internal read. ">IFileEOF()</a> or <a class="el" href="ifile_8h.html#a6c803c53f6270b21c375b7e07b05f1c8" title="IFileError returns error condition on an internal file. ">IFileError()</a>). And, if either happens before any data could be successfully read, <code>ERROR</code> is returned.</p>
<p class="enddd">The <code>error_string</code> variable is also set to a system-specific error code on failure. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to read an integer from the next line of the internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int an_int;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;int n;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;n =IFileScanf(ifilep, &quot;%d&quot;, &amp;an_int);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(n==1){</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;successfully read the integer: %d\n&quot;,an_int);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;} else {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   printf(&quot;problem reading the integer\n&quot;);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C <code>fscanf()</code> function. </dd></dl>

</div>
</div>
<a class="anchor" id="a40774bec8a23ec055276666af845a64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileSeek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileSeek moves to a position in an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset, in bytes, from a reference position where the new file pointer is desired to go. [in] origin Position used as reference for the offset. Specify one of the following constants : <table class="doxtable">
<tr>
<th>Constant </th><th>Reference Position  </th></tr>
<tr>
<td>SEEK_SET </td><td>Start of file </td></tr>
<tr>
<td>SEEK_CUR </td><td>Current position in the file </td></tr>
<tr>
<td>SEEK_END </td><td>End of file </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"><code>TRUE</code> is returned on success, <code>FALSE</code> otherwise.</p>
<p>For situations where the new position would be before the first byte, the file pointer position is not changed, and <code>FALSE</code> is returned.</p>
<p>For situations where the new position is beyond the last byte, this is allowed, but a subsequent read will fail. A subsequent write will "fill in" <code>NULL</code> bytes to get to this point before writing.</p>
<p class="enddd">The error_string variable is also set to a system-specific error code on failure. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to skip to byte 35 in an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(!IFileSeek(ifilep, 35L, SEEK_SET)){</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   printf(&quot;seek failed\n&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C <code>fseek()</code> function. </dd></dl>

</div>
</div>
<a class="anchor" id="a52b582df33eb77703df1219114a64368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileSetEOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileSetEOF sets End-Of-File condition on an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to set the <code>EOF</code> condition to, one of:<br />
 <code>TRUE</code> (if there was an <code>EOF</code> ), or:<br />
 <code>FALSE</code> (there was not an <code>EOF</code> ) <br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> is returned when the condition is set successfully, <code>FALSE</code> if not. The <code>error_string</code> variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to set that the previous read hit an <code>EOF</code> on an internal file named "/somename" succeeded or not. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep &lt; 0) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;if(!IFileSetEOF(ifilep, TRUE)){</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   printf(&quot;could not set EOF condition\n&quot;);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;} else {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   printf(&quot;successfully set EOF condition to TRUE\n&quot;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is used internally by the IFile* functions, and is not meant for usage by the normal user. </dd></dl>

</div>
</div>
<a class="anchor" id="a396268f8a6f981e1d514b6a08d545761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileSetWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileSetWrite sets the read/write property of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">property</td><td>The value to set the read/write property to:<br />
 GS_READ &ndash; internal file set to read-only mode<br />
 GS_WRITE &ndash; internal file set to read and write mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> is returned on success, <code>FALSE</code> otherwise. The <code>error_string</code> variable is also set to a system-specific error code on failure. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to create an internal file is named "/somename" and make it writeable. This is used by the internal IFileOpen routine when creating a new internal file. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(!IFileSetWrite(ifilep,GS_WRITE)){</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   printf(&quot;IFileSetWrite to read-write failed\n&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to enable IFileOpen to make an internal file have read and write rights on creation. </dd></dl>

</div>
</div>
<a class="anchor" id="aefcce5509a2d88c4c8d6f9c7cd9c9ccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileSetWriteability </td>
          <td>(</td>
          <td class="paramtype">hid_t&#160;</td>
          <td class="paramname"><em>file_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileSetWriteability sets the read/write property of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_id</td><td>The handle of the open geosci file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the internal file whose properties need to be altered. The internal file must not be open, otherwise this operation will fail. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">property</td><td>The value to set the read/write property to:<br />
 <code>GS_READ</code> &ndash; internal file set to read-only mode<br />
 <code>GS_WRITE</code> &ndash; internal file set to read and write mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> is returned on success, <code>FALSE</code> otherwise. The <code>error_string</code> variable is also set to a system-specific error code on failure.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to make sure the file is not writeable accidentally. The internal file is named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;if(!IFileSetWriteability(file_id,&quot;/somename&quot;,GS_READ)){</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   printf(&quot;IFileSetWriteability to read-only failed\n&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to enable a user to make an internal file have read and write rights like in the standard file system. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4b0643765d564071f1f55f33ebb6e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int IFileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileSize gets the #bytes in an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of characters in the internal file is returned. -1 is returned on error. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to know the size of an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;long int numbytes;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;numbytes = IFileSize(ifilep);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(numbytes &lt; 0) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;failed to get file size\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details</dt><dd>There is no equivalent standard C function to get the size of an open file. </dd></dl>

</div>
</div>
<a class="anchor" id="af1a575404e6e3648952ae70d281b3552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int IFileSizeHDF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileSizeHDF gets the #bytes in an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of characters in the internal file is returned. -1 is returned on error. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to know the size of an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;long int numbytes;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(ifilep &lt; 0) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;numbytes = IFileSizeHDF(ifilep);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(numbytes &lt; 0) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;failed to get file size\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details</dt><dd>There is no equivalent C function to get the size of an open file. This is distinct from <a class="el" href="ifile_8h.html#ae4b0643765d564071f1f55f33ebb6e10" title="IFileSize gets the #bytes in an internal file. ">IFileSize()</a> because this function asks the HDF5 system how big the dataset is. This is useful when we need to initialize the size when we open an existing <a class="el" href="structIFILE.html">IFILE</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abba9b29cbd1df9a22516366c96c528fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int IFileTell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileTell retrieves the current read/write position in an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position in the file is returned on success, and -1L on failure. The <code>error_string</code> variable is also set to a system-specific error code on failure. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to find the position of the file-pointer in an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;long int position;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;position = IFileTell(ifilep);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(position &lt; 0){</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;tell failed\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C <code>ftell()</code> function. </dd></dl>

</div>
</div>
<a class="anchor" id="af18bb2cd94833d1f8f7176d12537695c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileTruncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileTruncate changes the size of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The desired length, in bytes, of the file. Must be &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> is returned on success, <code>FALSE</code> otherwise. The <code>error_string</code> variable is also set to a system-specific error code on failure. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to make the new size be 1000 bytes for an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;long int icount;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;icount = 1000L;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if(!IFileTruncate(ifilep, icount)){</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   printf(&quot;truncate failed\n&quot;);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details</dt><dd>If the size of the file is less than <code>length</code>, then the file is increased to this size. If the size of the file is greater than <code>length</code>, then the file is decreased to this size. This function is meant to emulate as close as possible the standard C <code>ftruncate()</code> function. </dd></dl>

</div>
</div>
<a class="anchor" id="af21affaf53c0b66911c745dd6248ccf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileWrite writes bytes to an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>Pointer to an array where the bytes to write are read from. This must have at least size*count bytes of storage. Using a void pointer here allows the user to pass a <code>buf</code> variable of any type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of each element to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to write. Each element has a size of "size" bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The total number of elements successfully written is returned.</p>
<p>If this number differs from the count parameter, a writing error prevented the function from completing. In this case, the error indicator (IFileError) will be set for the stream.</p>
<p class="enddd">If either size or count is less than or equal to zero, the function returns zero and both the internal-file state and the content pointed to by <code>buf</code> remain unchanged. </p>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to write 10 ints in an int vector (starting at index 5) to an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int intvec[100];</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifilep &lt; 0) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;if(!IFileWrite(ifilep,intvec+5, sizeof(int),10L )){</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   printf(&quot;write failed\n&quot;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is meant to emulate as close as possible the standard C <code>fwrite()</code> function. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9797ae1226f5e7dc952e6686adfd8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileWriteAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileWriteAccess writes a new access code for an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The access code one wishes to write to the file, one of:<br />
 <code>IFILE_CLOSED</code> 0 <br />
 <code>IFILE_R</code> 1 <br />
 <code>IFILE_W</code> 2 <br />
 <code>IFILE_A</code> 3 <br />
 <code>IFILE_RP</code> 4 <br />
 <code>IFILE_WP</code> 5 <br />
 <code>IFILE_AP</code> 6 <br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> is returned on success, <code>FALSE</code> on failure. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one wants to set the access code to read-only for an internal file named "/somename". <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int access_code;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;if(!IFileWriteAccess(ifilep, IFILE_R)){</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   printf(&quot;could not set access code for internal file\n&quot;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function is used by the IFile* functions to set the internal-file access policy. They can be read, write, append, read-and-update, write-and-update, append-and-update, as well as closed. This routine is for use by the IFile* routines, and not normally for use by ordinary users. </dd></dl>

</div>
</div>
<a class="anchor" id="a04c255b65dccaf71c2e826a3ecfbd3ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileWriteStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileWriteStatus writes the status properties of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, <a class="el" href="ifile_8h.html#a6c8f114749f9cc332e2cf013098671a5" title="IFileClose closes an internal file in a GeoSci File. ">IFileClose</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>The value to set the status property to:<br />
 <code>IFILE_SUCCESS</code> &ndash; the last IFile operation succeeded <br />
 <code>IFILE_FAILURE</code> &ndash; the last IFile operation failed <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message associated with the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> is returned on success, <code>FALSE</code> otherwise. The <code>error_string</code> variable is also set to a system-specific error code on failure. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one has created an internal file is named "/somename" and the last write operation failed (using <a class="el" href="ifile_8h.html#a8a7e66cd5decd8a753cc05d87e796399" title="IFilePutc writes a single character to an internal file. ">IFilePutc()</a>). <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if(!IFileWriteStatus(ifilep,IFILE_FAILURE,&quot;IFilePutc() failed&quot;)){</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   printf(&quot;IFileWriteStatus failed\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details.</dt><dd>This function encapsulates writing the IFile status metadata. This function would not be used by the ordinary user. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2d81157c93e90f61645886bc82f4c8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFileWriteStatusMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structIFILE.html">IFILE</a> *&#160;</td>
          <td class="paramname"><em>ifilep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IFileWriteStatusMessage writes the status message of an internal file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ifile_8h.html#a659760c048381d534347487e14cd5e25" title="IFileOpen is used to open an internal file in a GeoSci File. ">IFileOpen</a>, FileClose, <a class="el" href="ifile_8h.html#a04c255b65dccaf71c2e826a3ecfbd3ee" title="IFileWriteStatus writes the status properties of an internal file. ">IFileWriteStatus</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifilep</td><td>The struct of the open internal file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message associated with the status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>TRUE</code> is returned on success, <code>FALSE</code> otherwise. The <code>error_string</code> variable is also set to a system-specific error code on failure. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Let's assume that one already has an GeoSci file, and one has created an internal file is named "/somename" and one wishes to write a status message that the last operation caused the file to hit the end-of-file. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;hid_t file_id;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;IFILE *ifilep;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ifilep = IFileOpen(file_id,&quot;/somename&quot;,&quot;w&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if(!ifilep) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   printf(&quot;IFileOpen failed on /somename\n&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(!IFileWriteStatusMessage(ifilep,&quot;IFilePutc() hit EOF&quot;)){</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   printf(&quot;IFileWriteStatusMessage failed\n&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Details</dt><dd>This function encapsulates writing the IFile status metadata. This function would not normally be called by a user. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 16 2016 18:04:14 for HDF5 Extras by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
