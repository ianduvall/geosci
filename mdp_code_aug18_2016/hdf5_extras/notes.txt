May 21, 2016
Leland Pierce

This is a library of stuff that I've written or gathered 
in order to make interfacing with HDF5 files more convenient.

In particular it has:

1. C interface to what I call an "internal file"
   The internal file has all the C high-level functions
   such as fopen, close, reading, writing, etc.
   This makes the HDF5 dataset useable as a standard file,
   for whatever needs a standard file interface.
   This was developed specifically for making a single HDF5
   dataset behave like a sqlite3 database file. This way sqlite3
   databases could be embedded within the HDF5 file. But it could be
   used for anything that expects a file interface.

2. A vfs interface implementation for sqlite3. Thsi uses the stuff in
   #1 to make a sqlite3 database embeddable into an HDF5 file as a dataset.

3. An interface to HDF5 attributes that's easier to use than the HDF5
   library version.

4. a malloc replacement (gmalloc), that just uses std stuff, but is
   there in case we need to change things.

5. a bunch of string functions for char * strings.

6. a replacement for char * strings that is more like the String in
   c++. Used to have safer string stuff....but only applied here and
   there due to the need to interface with other libraries that want
   me to pass char * instead.

========================================================================

June 18, 2016

11AM: need to test this new version of the library.
      grab code from /home/lep/notpci9/src/apps_hdf5/testing.c

      and modify for use here:
      /x/lep/OGRSF/libraries/hdf5_extras/test2.c

noon: GS_Dirname works
12:15: GS_FileCreate works
       GS_ImageCreate not working.....


      remember for the future:
      /x/lep/OGRSF/standards/metadata/sar_metadata/xsd_stuff
      this is where my xml metadata codes are....

1PM:  had GS_ImageCreate add a leading "/" to imagename if needed.
      works.

      GS_RasterCreate not working...
1:15PM:
      fixed GS_ValidMetadataName for new names for Rasters.
1:45PM: fixed: it was due to my metadata being junk...I fixed teh
                bstring stuff so it wrote valid metadata.
      test the other reports: Group and Raster
2PM:
      Group is empty, Raster is buggy....
      fixed raster dims: in wrong order, and used int where I should
                         have used long int.
3PM:  fixed group report too.
      there were quite a few things wriong....
      working on adding DatasetGetProjection,Datum,Bounds
      (keep these for groups, as some groups have these, some don't)

4PM:  ok, good. works. take a break.

5hrs

=======================================================================

June 19, 2016

330PM: continue checking library funcs.
       GS_RasterSizeInfo, GS_RasterPixelSize, GS_GetFilename

430PM: GS_GetIDName, GS_RasterCheckWindow*, GS_CheckWindowInside
6PM:   IFile*
7PM: done for now
3.5 hrs

=========================================================

June 20, 2016
730PM: getting sqlite3 in a ifile to work.
8PM:   working
       GS_ObjectGetH5Children: 
830PM: works.
       GS_ObjectGetGSChildren:

       relized need to change all:
lep@pierce3:/x/lep/OGRSF/libraries/hdf5_extras/src$ grep DATASET_TYPE *c
GS_DatasetGetType.c:\c DATASET_TYPE_INTERNAL_FILE  (1)\n
GS_DatasetGetType.c:\c DATASET_TYPE_RASTER         (2)\n
GS_DatasetGetType.c:\c DATASET_TYPE_METADATA       (3)\n
GS_DatasetGetType.c:\c DATASET_TYPE_METADATA_IFILE (4)\n
GS_DatasetGetType.c:\c DATASET_TYPE_UNKNOWN
GS_DatasetGetType.c:if(GS_DatasetGetType(raster_id) != DATASET_TYPE_RASTER ) {
GS_DatasetReport.c:  case GS_DATASET_TYPE_INTERNAL_FILE:
GS_DatasetReport.c:  case GS_DATASET_TYPE_RASTER:
GS_DatasetReport.c:  case GS_DATASET_TYPE_METADATA:
GS_DatasetReport.c:  case GS_DATASET_TYPE_METADATA_IFILE:
GS_DatasetSetType.c:C                   DATASET_TYPE_INTERNAL_FILE  1
GS_DatasetSetType.c:C                   DATASET_TYPE_RASTER         2
GS_DatasetSetType.c:C                   DATASET_TYPE_METADATA       3
GS_DatasetSetType.c:C                   DATASET_TYPE_METADATA_IFILE 4
GS_DatasetSetType.c:C       if(!GS_DatasetSetType(raster_id, DATASET_TYPE_RASTER) ) {
GS_DatasetSetType.c:  case GS_DATASET_TYPE_INTERNAL_FILE:
GS_DatasetSetType.c:  case GS_DATASET_TYPE_RASTER:
GS_DatasetSetType.c:  case GS_DATASET_TYPE_METADATA:
GS_DatasetSetType.c:  case GS_DATASET_TYPE_METADATA_IFILE:
GS_DatasetSetType.c:  case GS_DATASET_TYPE_INTERNAL_FILE:
GS_DatasetSetType.c:  case GS_DATASET_TYPE_RASTER:
GS_DatasetSetType.c:  case GS_DATASET_TYPE_METADATA:
GS_DatasetSetType.c:  case GS_DATASET_TYPE_METADATA_IFILE:
GS_ObjectIsIFile.c:  if(thetype != DATASET_TYPE_INTERNAL_FILE &&
GS_ObjectIsIFile.c:     thetype != DATASET_TYPE_METADATA_IFILE ){
GS_ObjectIsIFile.c:  if(thetype != DATASET_TYPE_INTERNAL_FILE &&
GS_ObjectIsIFile.c:     thetype != DATASET_TYPE_METADATA_IFILE ){
GS_ObjectIsMetadataDataset.c:  if(thetype != GS_DATASET_TYPE_METADATA &&
GS_ObjectIsMetadataDataset.c:     thetype != GS_DATASET_TYPE_METADATA_IFILE ){
GS_ObjectIsMetadataDataset.c:  if(thetype != GS_DATASET_TYPE_METADATA &&
GS_ObjectIsMetadataDataset.c:     thetype != GS_DATASET_TYPE_METADATA_IFILE ){
GS_ObjectIsMetadataIFileByID.c:  if(GS_DatasetGetType(dataset_id) !=  GS_DATASET_TYPE_METADATA_IFILE ){
GS_ObjectIsMetadataIFile.c:  if(GS_DatasetGetType(dataset_id) !=  GS_DATASET_TYPE_METADATA_IFILE ){
GS_ObjectIsRasterByID.c:  if(GS_DatasetGetType(dataset_id) != GS_DATASET_TYPE_RASTER){
GS_ObjectIsRaster.c:         GS_DatasetGetType(dataset_id),GS_DATASET_TYPE_RASTER);
GS_ObjectIsRaster.c:  if(GS_DatasetGetType(dataset_id) != GS_DATASET_TYPE_RASTER){
GS_RasterOpen.c:  if(dataset_type == GS_DATASET_TYPE_RASTER){
hdf5vfs.c:  if(GS_DatasetGetType(dataset_id) != GS_DATASET_TYPE_INTERNAL_FILE){
IFileOpen.c:                     to the C #define GS_DATASET_TYPE_INTERNAL_FILE
IFileOpen.c:  if(!GS_DatasetSetType(dataset_id,GS_DATASET_TYPE_INTERNAL_FILE)){


    to use GS_OBJECT_TYPE's instead.
    ie: remove GS_DATASET_TYPE's entirely.

10PM:     OK, finally GS_ObjectGetGSChildren works
total: 2.5hrs

===========================================================================
June 22, 2016
715PM:
       test lock/unlock

       making it possible to independently set writeability for a file
       took a bit of reworking of everything.
       so now we can set a file to RO even tho we opened it RW, by
       setting the writeable metadata.
       file writeable metadata can be updated as long as the file is
       RW, regardless of the value of the writeable metadata.
915PM:
       now test lock/unlock for images and rasters
          
935PM: ok, works for groups/images
       now rasters:
945PM: works.
2.5hrs

============================================================================
June 23, 2016
645PM: groupdelete, datasetdelete testing
745PM: works.
       debug documentation.

       NOTICED: yet to write GS_DataConversion
                in DatasetRead/Write

9PM:   still dealing with docs.
       
       YET: GS_DatatypeAsInteger, GS_DatatypeNumbytes,
       GS_DatatypeIsInteger, GS_ImageGeorefIO, 
       
       YET: consider that we have a func named:
            GS_GetRasterTypeAsString
            make sure the above funcs are named consistently


       YET: Look for geoscipy (any case), and database (any case)
            in all my C files, and change as needed.

10PM: thru groupcreate
3.25hrs
====================================================================

June 27, 2016
12PM: debug documentation, start after groupcreate
      
      yet: GS_VectorOpen

1:30PM: done with docs.v1
        deal with geoscipy --> geosci
215PM:  done
3PM:    done with ifile docs
        ...break....

7PM:    write refman.dox
        fileformat section is still pretty rough...and wrong.
9PM:    give up for now.
5hrs
======================================================

June 28, 2016
7PM:     work on fileformat section
745PM:   done.
         work on C++ standard interface layer.

         File:
         =====
         constructor or Create: name, type, descriptor (all strings)
         constructor or Open:   name, access (both strings)
               (2 difft constructors)
         destructor or FileClose:  ID
         Delete: name
         create_image: name, type, descriptor
         open_image:   name, access
         delete_image: name

         note: the "type" of file is a string that "goes with" the
               underlying implementations, and is defined as part of
               that implementation. The system can discover these when
               first started up and hence know the valid set of
               strings, the user must either know them, or use the 
               GUI (does not yet exist) which will present them to the
               user in the file-create gui panel.

         note: the "type" of image is a string that has valid values
               defined by the underlying impementation library that
               was chosen for the file-type. The user either knows
               these, or is given a choice by the gui.

         for example: file-type: hdf5, netcdf
                      image-type for hdf5 files: ignored: no choice
                      image-type for netcdf files: yet to figure
                      out...

         File/Create assumes "RW" access
         create_image assumes "RW" access


         Image:
         ======
         constructor/Create: name, type, descriptor
         constructor/Open: name, access
         destructor/Close: ID
         delete: name
         create_raster: name, raster-type, raster-data-type, 
                        npixels, nlines, descriptor
         open_raster: name, access
         delete_raster: name



         Raster:
         ========
         constructor/Create: name, raster-type, raster-data-type,
                             npixels, nlines, descriptor
         constructor/Open: nam, access
         destructor/Close: ID
         delete: name
         read: ID, from-window, to-window, buffer, (maybe: buffer-type)
         write: ID, from-window, to-window, buffer, (maybe: buffer-type)

 
         Metadata:
         ==========
         this is not an object, merely functions that allow
         us to create and edit metadata items associated with objects,
         such as files, images, and rasters.
         set-string-attribute: ID, name, value
         get-string-attribute: ID, name, value
         updateMetadata: ID, name, value
         appendMetadata: ID, name, value
         and miscellaneous specialized metadata funcs dealing with
             history, descriptors, etc....
         I guess these should be methods in each of our objects: 
              file, image, raster

         
830PM: done for now.

1.5hrs
-----------------------------------------------------------------------------


